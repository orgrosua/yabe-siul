<!DOCTYPE html>
<html>

<head>
    <link rel="preconnect" href="https://esm.sh" crossorigin>
</head>

<body>
    <script type="module">
        import { parse as parsePackage } from 'https://esm.sh/parse-package-name';

        let importShim;
        try {
            await (0, eval)('import("")');
        } catch (error) {
            if (error instanceof TypeError) {
                importShim = (0, eval)('u=>import(u)');
            } else {
                var s = document.createElement('script');
                s.src = 'https://esm.sh/shimport/index.js?raw';
                document.head.appendChild(s);
                importShim = __shimport__.load;
            }
        }

        async function parseConfig(configStr) {
            let mod = {};

            class RequireError extends Error {
                constructor(message, line) {
                    super(message);
                    this.name = 'RequireError';
                    this.line = line;
                }
            }

            const before = `(async function(module){
                const require = async (m, line) => {
                    if (typeof m !== 'string') {
                        throw new RequireError('The "id" argument must be of type string. Received ' + typeof m, line)
                    }
                    if (m === '') {
                        throw new RequireError("The argument 'id' must be a non-empty string. Received ''", line)
                    }
                    let result
                    try {
                        const _m = parsePackage(m);
                        const href = 'https://esm.sh/' + _m.name + '@' + _m.version + _m.path
                        result = await importShim(href)
                    } catch (error) {
                        throw new RequireError("Cannot find module '" + m + "'", line)
                    }
                    return result.default || result
                }`;
            const after = `
                siul = siul;
                module.exports = siul;
                })(mod)`;

            try {
                const evalString =
                    before +
                    '\n' +
                    configStr
                        .split('\n')
                        .map((line, i) => 
                            line.replace(
                                /\bimport\s+(.+)\s+from\s+['"](.+)['"]/g,
                                (_m, variable, url) => {
                                    return `const ${variable.indexOf('{') === -1
                                        ? `{default: ${variable}}`
                                        : variable.replace(/\s+as\s+/, ': ')
                                    } = await import('${url}')`;
                                }
                            )
                        )
                        .map((line, i) =>
                            line.replace(
                                /\brequire\(([^)]*)\)/g,
                                (_m, id) =>
                                    `(await require(${id.trim() === '' ? 'undefined' : id}, ${i + 1}))`
                            )
                        )
                        .join('\n') +
                    '\n' +
                    after;
                await eval(evalString);
            } catch (error) {
                let line;

                if (error instanceof RequireError) {
                    line = error.line;
                } else if (typeof error.line !== 'undefined') {
                    line = error.line - 1 - before.split('\n').length;
                } else {
                    const lines = error.stack.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        const re = /:([0-9]+):([0-9]+)/g;
                        const matches = [];
                        let match;
                        while ((match = re.exec(lines[i])) !== null) {
                            matches.push(match);
                        }

                        if (matches.length > 0) {
                            line =
                                parseInt(matches[matches.length - 1][1], 10) -
                                before.split('\n').length;
                            break;
                        }
                    }
                }

                return {
                    _error: {
                        message: error.name ? error.name + ': ' + error.message : error.message,
                        line: typeof line === 'undefined' ? undefined : line,
                    },
                };
            }

            return mod.exports || {};
        }

        // event listerner to receive message from the parent window
        window.addEventListener('message', async function (event) {
            const result = await parseConfig(event.data);
            window.parent.postMessage({
                type: 'action',
                action: 'resolve-config',
                config: JSON.parse(JSON.stringify(result)),
            }, '*');
        });

        // send ready message to parent with type iframe-ready
        window.parent.postMessage({ type: 'iframe-ready' }, '*');

        function withoutLogs(callback) {
            let fns = {
                log: console.log,
                warn: console.warn,
                error: console.error,
            }
            for (let key in fns) {
                console[key] = () => { }
            }
            let result = callback()
            for (let key in fns) {
                console[key] = fns[key]
            }
            return result
        }

    </script>
</body>

</html>